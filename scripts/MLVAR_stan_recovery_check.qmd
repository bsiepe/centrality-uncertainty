---
title: "Centrality"
format: html
---

# Preparation

```{r setup, include = FALSE}
# Libraries
library(tidyverse)
library(plyr)
library(rmarkdown)
library(graphicalVAR)
library(mlVAR)
library(parallel)
library(here)
library(broom)
library(gimme)
library(rstan)
library(bayesplot)
library(posterior)
library(gridExtra)
library(psych)
library(bayestestR)

source(here("scripts", "functions.R"))
set.seed(35037)
```

# Simulate data

## Simulate time series data with specific centrality/density
We simulate data from a multilevel model for now.

TODO: The following does not work yet when we scale the variables, because the true values are not scaled. Maybe we can just not scale the variables for LASSO, because the variances will be roughly equal anyway.

Alternatively, I could just use the simulated matrices to again simulate graphicalVAR data. This would solve the issue. 
```{r sim-data}
I <- 200
K <- 6
# number of regression outcomes
P <- 9
n_pc <-  K * (K - 1) / 2
idx_rho <- upper.tri(matrix(1, K, K, byrow = F)) %>% 
  c() %>% 
  which(.)
n_t <- rep(150, I)
beta_sd <- 0.1
kappa_sd <- 0.1

# non-sparse Graph to simulate from
graph_nonsparse <- readRDS(here("data","graph_nonsparse.RDS"))
# sparse DGP
#graph_sparse <- readRDS(here("data/graph_sparse.RDS"))

# Simulate data
ml_sim <- sim_gvar_loop(
                     graph = graph_nonsparse,
                     beta_sd = beta_sd,
                     kappa_sd = kappa_sd,
                     n_person = I,
                     n_time = n_t,
                     n_node = K,
                     max_try = 10000)

# Obtain individual models and data
Y <- ml_sim$data %>% map(function(x) apply(x,2,scale)) %>% 
  do.call(rbind, .) %>% 
  as.matrix()

# Obtain parameters
ml_beta <- ml_sim$beta %>% estimates_array2list()
ml_prec <- ml_sim$kappa %>% estimates_array2list()
ml_pcor <- ml_sim$pcor %>% estimates_array2list()

#ml_pcor_fixed <-

# Obtain centrality and density
# TODO double check the matrix formatting here
# where are the DVs, where is the IV
ml_outstrength <- lapply(ml_beta, function(x) {
  colMeans(abs(x))
})
ml_instrength <- lapply(ml_beta, function(x) {
  rowMeans(abs(x))
})
ml_strength <- lapply(ml_pcor, function(x) {
  diag(x) <- 0
  #x[lower.tri(x)] <- 0L # Matze: I think this is wrong!
  colMeans(abs(x))
})
ml_temporal_density <- lapply(ml_beta, function(x)
  mean(abs(x)))
# This should be equivalent to strength
ml_contemporaneous_density <- lapply(ml_pcor, function(x) {
  diag(x) <- 0
  #x[lower.tri(x)] <- 0L
  mean(abs(x))
})
```

## Simulate regression data
Simulate data from simple one-predictor regression model:
```{r sim-covariate}
true_cent <- centrality_mlvar_sim(ml_sim,
                                  sim_fn = "sim_gvar_loop")

tempdens <- unlist(true_cent$dens_temp) |> scale()
out_strength_1 <- sapply(true_cent$outstrength, `[`, 1) |> scale()
contemp_dens <- unlist(true_cent$dens_cont) |> scale()

# Simulate linear model data with regression coefficient of 0.5
eps <- 1

# Simulate error
resid <- rnorm(I, mean = 0, sd = eps)

# correlation matrix of true effects
rho <- c(1,  0, .2, .4,
         0,  1,  0,  0,
         .2, 0,  1,  0,
         .4, 0,  0,  1) %>% matrix(4, 4, byrow = T)
# cholesky decomposition of rho
L <- chol(rho)

# Simulate data for outcomes
outcome_temp_dens <- cbind(tempdens, rnorm(I), rnorm(I), rnorm(I))
outcome_contemp_dens <- cbind(contemp_dens, rnorm(I), rnorm(I), rnorm(I))
outcome_out_strength <- cbind(out_strength_1, rnorm(I), rnorm(I), rnorm(I))

# rotate outcomes to correlate with predictors and check resulting correlations
outcome_temp_dens <- outcome_temp_dens %*% L
(cor(outcome_temp_dens) - rho) %>% round(2)
lm(outcome_temp_dens[, 2] ~ tempdens) %>% coef() %>% .[2]
lm(outcome_temp_dens[, 3] ~ tempdens) %>% coef() %>% .[2]
lm(outcome_temp_dens[, 4] ~ tempdens) %>% coef() %>% .[2]


outcome_contemp_dens <- outcome_contemp_dens %*% L
(cor(outcome_contemp_dens) - rho) %>% round(2)
lm(outcome_contemp_dens[, 2] ~ contemp_dens) %>% coef() %>% .[2]
lm(outcome_contemp_dens[, 3] ~ contemp_dens) %>% coef() %>% .[2]
lm(outcome_contemp_dens[, 4] ~ contemp_dens) %>% coef() %>% .[2]

outcome_out_strength <- outcome_out_strength %*% L
(cor(outcome_out_strength) - rho) %>% round(2)
lm(outcome_out_strength[, 2] ~ out_strength_1) %>% coef() %>% .[2]
lm(outcome_out_strength[, 3] ~ out_strength_1) %>% coef() %>% .[2]
lm(outcome_out_strength[, 4] ~ out_strength_1) %>% coef() %>% .[2]


# define regression data and standardize
reg_data <-
  cbind(outcome_temp_dens[, 2:4] %>% apply(2, scale),
        outcome_contemp_dens[, 2:4] %>% apply(2, scale),
        outcome_out_strength[, 2:4] %>% apply(2, scale))

```

## Fit VAR Model in Stan
```{r stan data, renv.ignore = TRUE}
# prepare stan data
stan_data <-
  list(
    K = K,
    I = I,
    P = P,
    N_total = nrow(Y),
    n_t = n_t,
    n_pc = n_pc,
    idx_rho = array(idx_rho, dim = length(idx_rho)),
    Y = Y %>% apply(2, scale),
    reg_covariate = reg_data
  )
```

#### Strating Values
```{r  renv.ignore = TRUE}
# # initial values
# beta_start <-
#   rho_start <-
#   map(ml_data, function(x) {
#     cov(x[, 1:K])
#   }) %>% estimates_matrix_list2array()
# intercept_start <-
#   map(ml_data, function(x)
#     colMeans(x[, 1:K])) %>% do.call(rbind, .)
# theta_start <- map(ml_data, function(x) {
#     cov(x[, 1:K]) %>% chol() %>% t()
#   }) %>% estimates_matrix_list2array()
# n_chains <- 4
# 
# init_values <- 
#   lapply(1:n_chains, function(x) {
#     list(
#       # beta matrix
#       Beta_raw = beta_start,
#       mu_Beta = matrix(0, K, K),
#       sigma_Beta = matrix(0, K, K),
#       # network intercepts
#       Intercepts = intercept_start,
#       mu_Intercepts = rep(0, K),
#       sigma_Intercepts = matrix(0, K, K),
#       # matrix of innovations
#       L_Theta = theta_start,
#       rho_loc_raw = matrix(rep(0.5, I * n_pc), I, n_pc),
#       rho_var_raw = matrix(rep(sqrt(0.5), I * n_pc), I, n_pc),
#       mu_rho_loc = rep(0.5, n_pc),
#       sigma_rho_loc = rep(1, n_pc),
#       mu_rho_var = rep(sqrt(0.5), n_pc),
#       sigma_rho_var = rep(0, n_pc),
#       theta_sd_raw = matrix(rep(0, I * K), I, K),
#       mu_theta_sd = rep(0, K),
#       sigma_theta_sd = rep(0, K),
#       # regression
#       reg_intercept = rep(0, P),
#       reg_slope_density = rep(0, P),
#       reg_residual = rep(0, P)
#     )
#   })
```

```{r compile, renv.ignore = TRUE}
# Choose model to fit
model_name <- "MLVAR_lkj_only_no_intercept"
# Compile model
mlvar_model <-
  rstan::stan_model(
    file = here("scripts", "models", paste0(model_name, ".stan")),
    model_name = model_name#,
    # verbose = TRUE,
    # warn_pedantic = TRUE,
    # warn_uninitialized  = TRUE
  )
```

```{r sampling, message=FALSE, renv.ignore=TRUE, eval=FALSE}
# number of MCMC chains
n_chains <- 4
# Run sampler
mlvar_fit <- rstan::sampling(
  object = mlvar_model,
  pars = vars(contains("raw")),
  include = FALSE,
  data = stan_data,
  seed = 2023,
  chains = 4,
  cores = n_chains,
  warmup = 500,
  iter = 1000,
  init = 0,
  control = list(adapt_delta = 0.8),
  verbose = FALSE
)
rstan::get_elapsed_time(mlvar_fit) %>% 
  as.data.frame() %>% 
  rowMeans() %>% 
  max()/60

saveRDS(mlvar_fit, here("fits", paste0(model_name, "_fit.rds")))
```

```{r}
mlvar_fit <- readRDS(here("fits", "mlvar_fit.rds"))
```

## Effective sample size (ESS) & Rhat Plots
```{r ,  renv.ignore=TRUE, eval = FALSE}
# color scheme
color_scheme_set(scheme = "purple")
# Effective sample sizes
plot_neff <-
  mcmc_neff_hist(bayesplot::neff_ratio(mlvar_fit), binwidth = .01) +
  labs(title = "A") +
  guides(color = "none", fill = "none") +
  theme(
    legend.text = element_blank(),
    legend.key = element_blank(),
    title = element_text(size = 16, face = "bold")
  )
# Rhat
# BS: Why does this have missings?
plot_rhat <-
  bayesplot::mcmc_rhat_hist(bayesplot::rhat(mlvar_fit)) +
  labs(title = "B") +
  guides(color = "none", fill = "none") +
  theme(
    legend.text = element_blank(),
    legend.key = element_blank(),
    title = element_text(size = 16, face = "bold")
  ) +
  yaxis_text(on = TRUE)
# Combined plot
plot_diagnostics <- grid.arrange(plot_neff, plot_rhat, ncol = 2)
```
```{r}
rstan::check_hmc_diagnostics(mlvar_fit)
```

```{r}
param_ests <- summary(mlvar_fit)$summary %>% 
  as.data.frame() %>% 
  rownames_to_column("parameter")
```

## Parameter Recovery
### Betas
```{r renv.ignore=TRUE}
Beta_vec <-
  rstan::summary(mlvar_fit, pars =  "Beta", probs = .5)[["summary"]][,4] %>%
    unlist()

Beta_true_vec <- ml_beta %>% map(., function(x)t(x)) %>% unlist()

cor.test(Beta_vec, Beta_true_vec, method = "pearson")
cor.test(Beta_vec, Beta_true_vec, method = "spearman")
# plot
plot(Beta_vec,Beta_true_vec, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
abline(a = 0, b = 1, col = "red")
```


## Regression
```{r renv.ignore=TRUE}
bayesplot::mcmc_recover_intervals(
  true = rep(c(0, .2, .4),3),
  x = rstan::extract(object = mlvar_fit, "reg_slope_density_z") %>% do.call(cbind, .) %>%
    as_draws_matrix()
)

bayesplot::mcmc_intervals(
  x = rstan::extract(object = mlvar_fit, "reg_slope_density_z") %>% do.call(cbind, .) %>%
    as_draws_matrix()
)

```

```{r renv.ignore=TRUE}
bayesplot::mcmc_recover_intervals(
  true = rep(0,9),
  x = rstan::extract(object = mlvar_fit, c("reg_intercept")) %>% do.call(cbind, .) %>%
    as_draws_matrix()
)

bayesplot::mcmc_intervals(
  x = rstan::extract(object = mlvar_fit, c("reg_intercept")) %>% do.call(cbind, .) %>%
    as_draws_matrix()
)
```

## Partial Correlations
```{r renv.ignore=TRUE}
Rho_vec <- 
  rstan::summary(mlvar_fit, pars =  "Rho", probs = .5)[["summary"]][,4] %>%
    unlist()

Rho_true_vec <- ml_pcor %>% map(., function(x)t(x)) %>% unlist()
cor.test(Rho_vec, Rho_true_vec, method = "pearson")
cor.test(Rho_vec, Rho_true_vec, method = "spearman")
# plot
plot(Rho_vec, Rho_true_vec, xlim = c(-1, 1), ylim = c(-1, 1))
abline(a = 0, b = 1, col = "red")
```

```{r}
# Rho_vec <- 
#   rstan::summary(mlvar_fit, pars =  "mu_rho_loc", probs = .5)[["summary"]][,4] %>%
#     unlist() %>% pnorm(.)*2 - 1
# 
# Rho_true_vec <- ml_pcor_fixed %>% .[lower.tri(.)] %>%  unlist()
# 
# cor.test(Rho_vec, Rho_true_vec, method = "pearson")
# cor.test(Rho_vec, Rho_true_vec, method = "spearman")
# 
# # plot
# plot(Rho_vec, Rho_true_vec, xlim = c(-1, 1), ylim = c(-1, 1))
# abline(a = 0, b = 1, col = "red")
```

### Density
```{r renv.ignore=TRUE}
Beta_density <-
  rstan::summary(mlvar_fit, pars =  "Beta_density", probs = .5)[["summary"]][, 4] %>%
  unlist()

Beta_density_true <- ml_temporal_density %>% unlist()

cor.test(Beta_density, Beta_density_true, method = "pearson")
cor.test(Beta_density, Beta_density_true, method = "spearman")
# plot
plot(Beta_density, Beta_density_true, xlim = c(0, 1), ylim = c(0, 1))
abline(a = 0, b = 1, col = "red")
```

```{r renv.ignore=TRUE}
Rho_density <-  rstan::summary(mlvar_fit, pars =  "Rho_density", probs = .5)[["summary"]][, 4] %>%
  unlist()

Rho_density_true <- ml_contemporaneous_density %>% unlist()

cor.test(Rho_density, Rho_density_true, method = "pearson")
cor.test(Rho_density, Rho_density_true, method = "spearman")
# plot
plot(Rho_density, Rho_density_true, xlim = c(0, 1), ylim = c(0, 1))
abline(a = 0, b = 1, col = "red")
```

```{r renv.ignore=TRUE}
in_strength <-  rstan::summary(mlvar_fit, pars =  "Beta_in_strength", probs = .5)[["summary"]][, 4] %>%
  unlist()

in_strength_true <- ml_instrength %>% unlist()


cor.test(in_strength, in_strength_true, method = "pearson")
cor.test(in_strength, in_strength_true, method = "spearman")
# plot
plot(in_strength, in_strength_true, xlim = c(0, 1), ylim = c(0, 1))
abline(a = 0, b = 1, col = "red")
```

```{r renv.ignore=TRUE}
out_strength <- rstan::summary(mlvar_fit, pars =  "Beta_out_strength", probs = .5)[["summary"]][, 4] %>%
  unlist()

out_strength_true <- ml_outstrength %>% unlist()
cor.test(out_strength, out_strength_true, method = "pearson")
cor.test(out_strength, out_strength_true, method = "spearman")
# plot
plot(out_strength, out_strength_true, xlim = c(0, 1), ylim = c(0, 1))
abline(a = 0, b = 1, col = "red")
```

```{r renv.ignore=TRUE}
Rho_strength <- rstan::summary(mlvar_fit, pars =  "Rho_centrality", probs = .5)[["summary"]][, 4] %>%
  unlist()

Rho_strength_true <- ml_strength %>% unlist()
cor.test(Rho_strength, Rho_strength_true, method = "pearson")
cor.test(Rho_strength, Rho_strength_true, method = "spearman")
# plot
plot(Rho_strength, Rho_strength_true, xlim = c(0, 1), ylim = c(0, 1))
abline(a = 0, b = 1, col = "red")
```

# Extract estimates
```{r renv.ignore=TRUE}
estimates_list <- extract_all_estimates(mlvar_fit, I, K)
```