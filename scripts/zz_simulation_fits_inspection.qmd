---
title: "simulation_fits_inspection"
format: html
editor: source
---

# Prep

In this file, we investigate different simulation fits

```{r}
library(tidyverse)
library(lm.beta)
```

```{r}
sim_res_4 <- readRDS("~/centrality-uncertainty/sim_full.rds-results_pc04798/results-row-4.rds")
```

# Analyze bmlVAR

Compare contemporaneous fits, which seemed off:

```{r}
ut <- function(x){
  x[upper.tri(x)]
}

sim_res_4$results[[1]]$bmlvar$fit_bmlvar$pcor[[2]]
ut(sim_res_4$results[[1]]$pcor[[2]])

# Look at absolute differences across all individuals
Reduce("+", Map("abs", Map("-", sim_res_4$results[[1]]$bmlvar$fit_bmlvar$pcor, sim_res_4$results[[1]]$pcor))) / length(sim_res_4$results[[1]]$bmlvar$dens_temp)

# Check if there is a wrong negative sign
reverse_sign_pcor <- lapply(sim_res_4$results[[1]]$bmlvar$fit_bmlvar$pcor, function(x) x*-1)

Reduce("+", Map("abs", Map("-", reverse_sign_pcor, sim_res_4$results[[1]]$pcor))) / length(sim_res_4$results[[1]]$bmlvar$dens_temp)



```


Look at temporal fit:

```{r}
# Look at absolute differences across all individuals
Reduce("+", Map("abs", Map("-", sim_res_4$results[[1]]$bmlvar$fit_bmlvar$beta, sim_res_4$results[[1]]$beta))) / length(sim_res_4$results[[1]]$bmlvar$dens_temp)

# Only look at bias, not absolute
bmlvar_beta_bias <- Reduce("+", Map("-", sim_res_4$results[[1]]$bmlvar$fit_bmlvar$beta, sim_res_4$results[[1]]$beta)) / length(sim_res_4$results[[1]]$bmlvar$dens_temp)


# check if rows and columns were swapped
# transposed_beta <- lapply(sim_res_4$results[[1]]$bmlvar$fit_bmlvar$beta, t)

# bmlvar_beta_bias <- Reduce("+", Map("-", transposed_beta, sim_res_4$results[[1]]$beta)) / length(transposed_beta)


as.data.frame(as.table(bmlvar_beta_bias)) |> 
  rename(Variable1 = Vasim_res_4, Variable2 = Var2, Correlation = Freq) |> 
  mutate(Variable1 = factor(Variable1, levels = c("A", "B", "C", "D", "E", "F"))) |> 
  mutate(Variable2 = factor(Variable2, levels = c("A", "B", "C", "D", "E", "F"))) |> 
  mutate(Variable1 = fct_rev(Variable1)) |>  # Reverse order of Variable1
  ggplot(aes(y = Variable1, x = Variable2, fill = Correlation)) +
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.3f", Correlation)), size = 4, color = "black") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  labs(
    title = "Bias of VAR Matrix",
    y = "Variable 1",
    x = "Variable 2",
    fill = "Bias"
  ) +
  theme_centrality() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid = element_blank()
  )
```



## Regression outcomes

Unstandardized regression coefs:
```{r}
sim_res_4$results[[1]]$bmlvar$reg_bmlvar$regression_slope$median
```

Standardized regression coefs: 

```{r}
get_filtered_summary <- function(result, iteration) {
  # Extract and filter the summary data
  result_df <- result$bmlvar$summary_bmlvar |> 
    as.data.frame() |> 
    rownames_to_column(var = "param") |> 
    filter(param %in% c("reg_slope_density_z[3]", 
                        "reg_slope_density_z[6]",
                        "reg_slope_density_z[9]",
                        "reg_slope_density[3]",
                        "reg_slope_density[6]",
                        "reg_slope_density[9]"))
  
  result_df$iteration <- iteration
  
  return(result_df)
}

summary_list <- lapply(seq_along(sim_res_4$results), function(i) {
  get_filtered_summary(sim_res_4$results[[i]], i)
})

final_summary_df <- bind_rows(summary_list)

final_summary_df

final_summary_df |> 
  filter(!grepl("_z", param)) |> 
  separate_wider_delim(param, delim = "[", names = c("param", "param_num")) |> 
  mutate(param_num = gsub("]", "", param_num)) |> 
  mutate(param_num = as.factor(param_num)) |> 
  rename(posterior_mean = mean,
         posterior_sd = sd) |> 
  group_by(param_num) |> 
  reframe(across(c(posterior_mean, posterior_sd, "2.5%", "97.5%"),
                   mean))

```



Plot them all (first need to account for the weird data structure where the results are a vector of length 9)

```{r}
slopes <- lapply(sim_res_4$results, function(x){
  tmp <- x$bmlvar$reg_bmlvar$regression_slope$median
  df_slopes <- data.frame(
    # true coefficients
    zero = tmp[c(1,4,7)],
    two = tmp[c(2,5,8)],
    four = tmp[c(3,6,9)],
    coef = c("instrength", "outstrength", "strength")
  )
  df_slopes
})


slopes |> 
  bind_rows() |> 
  rename(
    "0.0" = zero,
    "0.2" = two,
    "0.4" = four
  ) |> 
  pivot_longer(cols = !coef, 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  # filter(coef != "strength") |> 
  ggplot(aes(x = reg_coef, y = value, col = coef)) + 
  geom_point(position = position_jitter(width = .1, height = 0))+
  labs(x = "True Regression Slope",
       y = "Estimated Regression Slope",
       title = "BmlVAR Estimates of Regresion Slope",
       caption = "n = 200") +
  theme_centrality()+
  theme(text = element_text(size = 21))+
  scale_color_manual(values = ggokabeito::palette_okabe_ito(c(5,1,3)))

```


Now plot them with their credible intervals:
```{r}
slopes_ci <- lapply(sim_res_4$results, function(x){
  medians <- x$bmlvar$reg_bmlvar$regression_slope$median
  ci_l <- x$bmlvar$reg_bmlvar$regression_slope$ci_95_l
  ci_u <- x$bmlvar$reg_bmlvar$regression_slope$ci_95_u
  
  df_slopes <- data.frame(
    # True coefficients
    zero = medians[c(1,4,7)],
    zero_l = ci_l[c(1,4,7)],
    zero_u = ci_u[c(1,4,7)],
    two = medians[c(2,5,8)],
    two_l = ci_l[c(2,5,8)],
    two_u = ci_u[c(2,5,8)],
    four = medians[c(3,6,9)],
    four_l = ci_l[c(3,6,9)],
    four_u = ci_u[c(3,6,9)],
    coef = c("instrength", "outstrength", "strength")
  )
  df_slopes
})


slopes_df <- do.call(rbind, slopes_ci)

slopes_df_ci <- slopes_df |> 
  pivot_longer(
    cols = !coef, 
    names_to = c("true_effect", ".value"),         # create "true_effect" and keep other parts as is
    names_sep = "_",                               # separator between "zero", "zero_l", etc.
    values_drop_na = TRUE                          
  ) |> 
  mutate(true_effect = recode(true_effect, zero = 0, two = 2, four = 4))
```

Plot credible intervals for strongest effect:
```{r}
slopes_df |> 
  select(four, four_l, four_u, coef) |> 
  filter(coef == "outstrength") |> 
  mutate(iteration = row_number() * 0.1) |> 
  ggplot(aes(y = four, x = four))+
  geom_point(position=position_dodge(width=0.5))+
  geom_errorbar(
        aes(xmin = four_l, xmax = four_u),
        linetype = "dotted",
        position=position_dodge(width=0.5))

```





## Use two-step with BmlVAR centrality estimates

Try using centrality point estimates obtained with BmlVAR to estimate a normal `lm()`.

```{r}
get_lm_beta_coefficient <- function(result) {
  out_est <- sapply(result$bmlvar$outstrength, function(x) x[1])
  
  covar_true <- result$covariate_out_strength[, 4]
  
  df_out <- data.frame(
    outstrength = out_est, 
    covariate = covar_true
  )
  
  test <- lm.beta::lm.beta(lm(covariate ~ outstrength, data = df_out))
  return(test$standardized.coefficients[2])
}

coefficients_list <- lapply(sim_res_4$results, get_lm_beta_coefficient)
coefficients_vector <- unlist(coefficients_list)

coefficients_vector

```

Now without standardization:

```{r}
get_lm_coefficient <- function(result) {
  out_est <- sapply(result$bmlvar$outstrength, function(x) x[1])
  
  covar_true <- result$covariate_out_strength[, 4]
  
  df_out <- data.frame(
    outstrength = out_est, 
    covariate = covar_true
  )
  
  test <- summary(lm(covariate ~ outstrength, data = df_out))
  return(test$coefficients[2])
}

coefficients_list <- lapply(sim_res_4$results, get_lm_beta_coefficient)
coefficients_vector <- unlist(coefficients_list)

coefficients_vector
```


## Visualize centralities
```{r}
centrality_list_bmlvar <- list()

for (i in seq_along(sim_res_4$results)) {
  df_temp <- data.frame(
    bmlvar_outstrength = sapply(sim_res_4$results[[i]]$bmlvar$outstrength, function(x) x[[1]]),
    bmlvar_instrength = sapply(sim_res_4$results[[i]]$bmlvar$instrength, function(x) x[[1]]),
    bmlvar_strength = sapply(sim_res_4$results[[i]]$bmlvar$strength, function(x) x[[1]]),
    true_outstrength = sapply(sim_res_4$results[[i]]$true_cent$outstrength, function(x) x[[1]]),
    true_instrength = sapply(sim_res_4$results[[i]]$true_cent$instrength, function(x) x[[1]]),
    true_strength = sapply(sim_res_4$results[[i]]$true_cent$strength, function(x) x[[1]])
  )
  
  centrality_list_bmlvar[[i]] <- df_temp
}

df_centrality_bmlvar <- do.call(rbind, centrality_list_bmlvar)

# add an identifier column to track which element each row came from
df_centrality_bmlvar$sim_rep <- rep(seq_along(sim_res_4$results), sapply(centrality_list_bmlvar, nrow))



df_centrality_bmlvar |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(delim = "_", cols = name, names = c("est", "centrality")) |> 
  pivot_wider(id_cols = c(sim_rep, centrality), names_from = est) |> 
  unnest_longer(col = c(bmlvar, true)) |> 
  ggplot(aes(x = true, y = bmlvar)) + 
  geom_point() + 
  geom_smooth() + 
  theme_centrality() +
  facet_grid(~centrality)+
  scale_x_continuous(limits = c(0,.3))+
  scale_y_continuous(limits = c(0,.3))
```
Check their standard deviations and SD
```{r}
df_centrality_bmlvar |> 
  group_by(sim_rep) |> 
  summarize(across(everything(),list(mean = mean, sd = sd))) |> 
  ungroup() |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(cols = name, delim = "_", names = c("est", "centrality", "summary")) |> 
  pivot_wider(id_cols = c(sim_rep, est, centrality), names_from = summary, values_from = value) |> 
  group_by(est, centrality) |> 
  summarize(across(c(mean, sd), 
                   mean))
```









## Check Convergence
```{r}
sim_res_4$results[[1]]$bmlvar$summary_bmlvar |> 
  as.data.frame() |> 
  mutate(na_rhat = is.na(Rhat)) |> 
  rownames_to_column("param") |> 
  filter(grepl("Sigma", param)) |> 
  View()
```





# Analyze other models

## graphicalVAR

### Regression outcomes

```{r}
l_coefs <- list()
l_coefs$zero <- vector()
l_coefs$two <- vector()
l_coefs$four <- vector()

for(i in 1:1){
  l_coefs$zero[i] <- lm.beta(sim_res_4$results[[i]]$gvar$reg_outstrength[[1]])$standardized.coefficients[2]
  l_coefs$two[i] <- lm.beta(sim_res_4$results[[i]]$gvar$reg_outstrength[[2]])$standardized.coefficients[2]
  l_coefs$four[i] <- lm.beta(sim_res_4$results[[i]]$gvar$reg_outstrength[[3]])$standardized.coefficients[2]
}

l_coefs |> 
  dplyr::bind_rows(.id = "true_coef") |> 
    pivot_longer(cols = everything(), 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  ggplot(aes(x = reg_coef, y = value)) + 
  geom_point()

```


Unstandardized:

```{r}
l_coefs <- list()
l_coefs$zero <- vector()
l_coefs$two <- vector()
l_coefs$four <- vector()

for(i in 1:10){
  l_coefs$zero[i] <- summary(sim_res_4$results[[i]]$gvar$reg_strength[[1]])$coefficients[2]
  l_coefs$two[i] <- summary(sim_res_4$results[[i]]$gvar$reg_strength[[2]])$coefficients[2]
  l_coefs$four[i] <- summary(sim_res_4$results[[i]]$gvar$reg_strength[[3]])$coefficients[2]
}

l_coefs |> 
  dplyr::bind_rows(.id = "true_coef") |> 
    pivot_longer(cols = everything(), 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  ggplot(aes(x = reg_coef, y = value)) + 
  geom_point()

```


### Visualize centralities

```{r}
centrality_list_gvar <- list()

for (i in seq_along(sim_res_4$results)) {
  df_temp <- data.frame(
    gvar_outstrength = sapply(sim_res_4$results[[i]]$gvar$outstrength, function(x) x[[1]]),
    gvar_instrength = sapply(sim_res_4$results[[i]]$gvar$instrength, function(x) x[[1]]),
    gvar_strength = sapply(sim_res_4$results[[i]]$gvar$strength, function(x) x[[1]]),
    true_outstrength = sapply(sim_res_4$results[[i]]$true_cent$outstrength, function(x) x[[1]]),
    true_instrength = sapply(sim_res_4$results[[i]]$true_cent$instrength, function(x) x[[1]]),
    true_strength = sapply(sim_res_4$results[[i]]$true_cent$strength, function(x) x[[1]])
  )
  
  centrality_list_gvar[[i]] <- df_temp
}

df_centrality_gvar <- do.call(rbind, centrality_list_gvar)

# add an identifier column to track which element each row came from
df_centrality_gvar$sim_rep <- rep(seq_along(sim_res_4$results), sapply(centrality_list_gvar, nrow))



df_centrality_gvar |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(delim = "_", cols = name, names = c("est", "centrality")) |> 
  pivot_wider(id_cols = c(sim_rep, centrality), names_from = est) |> 
  unnest_longer(col = c(gvar, true)) |> 
  ggplot(aes(x = true, y = gvar)) + 
  geom_point() + 
  geom_smooth() + 
  theme_centrality() +
  facet_grid(~centrality)
```

Look at their SDs
```{r}
df_centrality_gvar |> 
  group_by(sim_rep) |> 
  summarize(across(everything(),list(mean = mean, sd = sd))) |> 
  ungroup() |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(cols = name, delim = "_", names = c("est", "centrality", "summary")) |> 
  pivot_wider(id_cols = c(sim_rep, est, centrality), names_from = summary, values_from = value)
```

## mlVAR

### Network Estimation

Calculate average difference

```{r}
# Temporal Network
Reduce("+", Map("abs", Map("-", sim_res_4$results[[1]]$mlvar$fit_mlvar$beta,sim_res_4$results[[1]]$beta))) / 200

# Contemporaneous Network
Reduce("+", Map("abs", Map("-", sim_res_4$results[[1]]$mlvar$fit_mlvar$pcor,sim_res_4$results[[1]]$pcor))) / 200
```

Create a long PDF with a heatmap of the differences for each individual, maybe we can find some patterns on why it didn't work:

```{r}
# Create a function to generate heatmaps and save them to a PDF
generate_heatmaps <- function(true_matrices, estimated_matrices, output_file, n_ind) {
  
  # Check that both lists are of the same length
  if (length(true_matrices) != length(estimated_matrices)) {
    stop("The lists of matrices must have the same length.")
  }
  
  # Open a PDF device
  pdf(file = output_file, width = 8, height = 10)
  
  # Loop over each pair of matrices
  for (i in 1:n_ind) {
    
    # Compute the difference matrix
    diff_matrix <- true_matrices[[i]] - estimated_matrices[[i]]
    
    # Convert the difference matrix to a data frame for ggplot
    diff_df <- reshape2::melt(diff_matrix)
    
    # Generate the heatmap
    p <- ggplot(diff_df, aes(x = Vasim_res_4, y = Var2, fill = value)) +
      geom_tile() +
      scale_fill_gradient2(low = "darkblue", mid = "white", high = "darkred", midpoint = 0) +
      # plot the numerical value
      geom_text(aes(label = round(value, 2)), color = "black", size = 3) +
      labs(title = paste("Difference Matrix for Individual", i),
           x = "",
           y = "",
           fill = "Difference") +
      theme_minimal()
    
    # Print the plot to the PDF
    print(p)
  }
  
  # Close the PDF device
  dev.off()
}

# Example usage
# Assuming true_matrices and estimated_matrices are defined
# true_matrices <- list(matrix(rnorm(25), nrow = 5), matrix(rnorm(25), nrow = 5))
# estimated_matrices <- list(matrix(rnorm(25), nrow = 5), matrix(rnorm(25), nrow = 5))

# Call the function
generate_heatmaps(sim_res_4$results[[1]]$beta, sim_res_4$results[[1]]$mlvar$fit_mlvar$beta, "heatmaps.pdf", n_ind = 200)

```



### Centrality

Somehow, the rank correlation for mlVAR is quite bad. Plot some examples:

```{r}
centrality_list_mlvar <- list()

for (i in seq_along(sim_res_4$results)) {
  df_temp <- data.frame(
    mlvar_outstrength = sapply(sim_res_4$results[[i]]$mlvar$outstrength, function(x) x[[1]]),
    mlvar_instrength = sapply(sim_res_4$results[[i]]$mlvar$instrength, function(x) x[[1]]),
    mlvar_strength = sapply(sim_res_4$results[[i]]$mlvar$strength, function(x) x[[1]]),
    true_outstrength = sapply(sim_res_4$results[[i]]$true_cent$outstrength, function(x) x[[1]]),
    true_instrength = sapply(sim_res_4$results[[i]]$true_cent$instrength, function(x) x[[1]]),
    true_strength = sapply(sim_res_4$results[[i]]$true_cent$strength, function(x) x[[1]])
  )
  
  centrality_list_mlvar[[i]] <- df_temp
}

df_centrality_mlvar <- do.call(rbind, centrality_list_mlvar)

# add an identifier column to track which element each row came from
df_centrality_mlvar$sim_rep <- rep(seq_along(sim_res_4$results), sapply(centrality_list_mlvar, nrow))

df_centrality_mlvar


df_centrality_mlvar |> 
  ggplot(aes(x = true_outstrength, y = mlvar_outstrength)) + 
  geom_point() + 
  geom_smooth() + 
  theme_centrality()
```


What is their standard deviation?
```{r}
df_centrality_mlvar |> 
  group_by(sim_rep) |> 
  summarize(across(everything(),list(mean = mean, sd = sd))) |> 
  ungroup() |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(cols = name, delim = "_", names = c("est", "centrality", "summary")) |> 
  pivot_wider(id_cols = c(sim_rep, est, centrality), names_from = summary, values_from = value)
```

mlVAR severely underestimates the variability of contemporaneous networks.







### Regression outcomes

```{r}
l_coefs <- list()
l_coefs$zero <- vector()
l_coefs$two <- vector()
l_coefs$four <- vector()

for(i in 1:1){
  l_coefs$zero[i] <- lm.beta(sim_res_4$results[[i]]$mlvar$reg_outstrength[[1]])$standardized.coefficients[2]
  l_coefs$two[i] <- lm.beta(sim_res_4$results[[i]]$mlvar$reg_outstrength[[2]])$standardized.coefficients[2]
  l_coefs$four[i] <- lm.beta(sim_res_4$results[[i]]$mlvar$reg_outstrength[[3]])$standardized.coefficients[2]
}

l_coefs |> 
  dplyr::bind_rows(.id = "true_coef") |> 
    pivot_longer(cols = everything(), 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  ggplot(aes(x = reg_coef, y = value)) + 
  geom_point()

```

Unstandardized:

```{r}
l_coefs <- list()
l_coefs$zero <- vector()
l_coefs$two <- vector()
l_coefs$four <- vector()

for(i in 1:10){
  l_coefs$zero[i] <- summary(sim_res_4$results[[i]]$mlvar$reg_outstrength[[1]])$coefficients[2]
  l_coefs$two[i] <- summary(sim_res_4$results[[i]]$mlvar$reg_outstrength[[2]])$coefficients[2]
  l_coefs$four[i] <- summary(sim_res_4$results[[i]]$mlvar$reg_outstrength[[3]])$coefficients[2]
}

l_coefs |> 
  dplyr::bind_rows(.id = "true_coef") |> 
    pivot_longer(cols = everything(), 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  ggplot(aes(x = reg_coef, y = value)) + 
  geom_point()
```



## GIMME

### Regression Outcomes

Standardized coefficients:
```{r}
l_coefs <- list()
l_coefs$zero <- vector()
l_coefs$two <- vector()
l_coefs$four <- vector()

for(i in 1:length(sim_res_4$results)){
  l_coefs$zero[i] <- lm.beta(sim_res_4$results[[i]]$gimme$reg_outstrength[[1]])$standardized.coefficients[2]
  l_coefs$two[i] <- lm.beta(sim_res_4$results[[i]]$gimme$reg_outstrength[[2]])$standardized.coefficients[2]
  l_coefs$four[i] <- lm.beta(sim_res_4$results[[i]]$gimme$reg_outstrength[[3]])$standardized.coefficients[2]
}

l_coefs |> 
  dplyr::bind_rows(.id = "true_coef") |> 
    pivot_longer(cols = everything(), 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  ggplot(aes(x = reg_coef, y = value)) + 
  geom_point()
```

Unstandardized:

```{r}
l_coefs <- list()
l_coefs$zero <- vector()
l_coefs$two <- vector()
l_coefs$four <- vector()

for(i in 1:10){
  l_coefs$zero[i] <- summary(sim_res_4$results[[i]]$gimme$reg_outstrength[[1]])$coefficients[2,1]
  l_coefs$two[i] <- summary(sim_res_4$results[[i]]$gimme$reg_outstrength[[2]])$coefficients[2,1]
  l_coefs$four[i] <- summary(sim_res_4$results[[i]]$gimme$reg_outstrength[[3]])$coefficients[2,1]
}

l_coefs |> 
  dplyr::bind_rows(.id = "true_coef") |> 
    pivot_longer(cols = everything(), 
               names_to = "reg_coef") |> 
  mutate(reg_coef = as.factor(reg_coef)) |> 
  ggplot(aes(x = reg_coef, y = value)) + 
  geom_point()
```



### Visualize centralities

```{r}
centrality_list_gimme <- list()

for (i in seq_along(sim_res_4$results)) {
  df_temp <- data.frame(
    gimme_outstrength = sapply(sim_res_4$results[[i]]$gimme$outstrength, function(x) x[[1]]),
    gimme_instrength = sapply(sim_res_4$results[[i]]$gimme$instrength, function(x) x[[1]]),
    gimme_strength = sapply(sim_res_4$results[[i]]$gimme$strength, function(x) x[[1]]),
    true_outstrength = sapply(sim_res_4$results[[i]]$true_cent$outstrength, function(x) x[[1]]),
    true_instrength = sapply(sim_res_4$results[[i]]$true_cent$instrength, function(x) x[[1]]),
    true_strength = sapply(sim_res_4$results[[i]]$true_cent$strength, function(x) x[[1]])
  )
  
  centrality_list_gimme[[i]] <- df_temp
}

df_centrality_gimme <- do.call(rbind, centrality_list_gimme)

# add an identifier column to track which element each row came from
df_centrality_gimme$sim_rep <- rep(seq_along(sim_res_4$results), sapply(centrality_list_gimme, nrow))



df_centrality_gimme |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(delim = "_", cols = name, names = c("est", "centrality")) |> 
  pivot_wider(id_cols = c(sim_rep, centrality), names_from = est) |> 
  unnest_longer(col = c(gimme, true)) |> 
  ggplot(aes(x = true, y = gimme)) + 
  geom_point() + 
  geom_smooth() + 
  theme_centrality() +
  facet_grid(~centrality)
```

Look at their SDs
```{r}
df_centrality_gimme |> 
  group_by(sim_rep) |> 
  summarize(across(everything(),list(mean = mean, sd = sd))) |> 
  ungroup() |> 
  pivot_longer(cols = !sim_rep) |> 
  separate_wider_delim(cols = name, delim = "_", names = c("est", "centrality", "summary")) |> 
  pivot_wider(id_cols = c(sim_rep, est, centrality), names_from = summary, values_from = value)
```


# Overall results

Look at RMSE
```{r}
sim_res <- readRDS("~/centrality-uncertainty/sim151124.rds")
sim_res |> 
  select(c(dgp, n_id, n_tp, contains("rmse"))) |> 
  select(!contains("mcse")) |>  
  pivot_longer(cols = !c(dgp, n_id, n_tp)) |> 
  mutate(name = gsub("^[^.]*\\.", "", name)) |>  
  View()
```


Look at power: 
```{r}
sim_res |> 
  select(c(dgp, n_id, n_tp, contains("power"))) |> 
  select(!contains("mcse")) |>  
  pivot_longer(cols = !c(dgp, n_id, n_tp)) |> 
  mutate(name = gsub("^[^.]*\\.", "", name)) |>  
  separate_wider_delim(cols = name,
                       delim = "_",
                       names = c("power", "reg", "feature",
                                 "method", "stat")) |> 
  filter(power != "poweroneside") |> 
  select(!c(power, stat)) |>
  pivot_wider(id_cols = c(dgp, n_id, n_tp, reg, feature),
              names_from = method, values_from = value) |> 
  View()
```

Plot the power: 
```{r}
sim_res |> 
  select(c(dgp, n_id, n_tp, contains("power"))) |> 
  select(!contains("mcse")) |>  
  pivot_longer(cols = !c(dgp, n_id, n_tp)) |> 
  mutate(name = gsub("^[^.]*\\.", "", name)) |>  
  separate_wider_delim(cols = name,
                       delim = "_",
                       names = c("power", "reg", "feature",
                                 "method", "stat")) |> 
  filter(power != "poweroneside") |> 
  select(!c(power, stat)) |> 
  ggplot(aes(x = method, y = value, col = method))+
  geom_point()+
  ggh4x::facet_nested(n_id + feature ~ reg,
                      axes = "all",
                      remove_labels = "y")+
  theme_centrality()
```




## Eigenvalues of DGP

To check multicollinearity 
```{r}
comp_eigen <- function(data){
  gram <- t(as.matrix(data)) %*% as.matrix(data)
  evs <- eigen(gram)$values
  return(evs)
}

sapply(sim_res_4$results[[1]]$data, comp_eigen)

```


## Within-Iteration Correlation between Centrality Measures

True centrality measures seem to be mostly uncorrelated:
```{r}
cor_results <- lapply(sim_res_4[["results"]], function(res) {
  outstrength <- sapply(res$true_cent$outstrength, function(x) { x[[1]] })
  instrength <- sapply(res$true_cent$instrength, function(x) { x[[1]] })
  strength <- sapply(res$true_cent$strength, function(x) { x[[1]] })
  
  cent <- data.frame(
    outstrength = outstrength,
    instrength = instrength,
    strength = strength
  )
  
  cor(cent)
})


cor_summary <- do.call(rbind, lapply(seq_along(cor_results), function(i) {
  cor_matrix <- cor_results[[i]]
  data.frame(
    element = i,
    variable_1 = rownames(cor_matrix)[row(cor_matrix)],
    variable_2 = colnames(cor_matrix)[col(cor_matrix)],
    correlation = as.vector(cor_matrix)
  )
}))

# Filter out duplicate entries for symmetry in the correlation matrices
cor_summary <- cor_summary[cor_summary$variable_1 <= cor_summary$variable_2, ]

cor_summary |> 
  filter(variable_1 != variable_2) |> 
  View()
```

Estimated centrality measures for BmlVAR also seem to be mostly uncorrelated or only weakly correlated:
```{r}
cor_results <- lapply(sim_res_4[["results"]], function(res) {
  outstrength <- sapply(res$bmlvar$outstrength, function(x) { x[[1]] })
  instrength <- sapply(res$bmlvar$instrength, function(x) { x[[1]] })
  strength <- sapply(res$bmlvar$strength, function(x) { x[[1]] })
  
  cent <- data.frame(
    outstrength = outstrength,
    instrength = instrength,
    strength = strength
  )
  
  cor(cent)
})

cor_summary <- do.call(rbind, lapply(seq_along(cor_results), function(i) {
  cor_matrix <- cor_results[[i]]
  data.frame(
    element = i,
    variable_1 = rownames(cor_matrix)[row(cor_matrix)],
    variable_2 = colnames(cor_matrix)[col(cor_matrix)],
    correlation = as.vector(cor_matrix)
  )
}))

# Filter out duplicate entries for symmetry in the correlation matrices
cor_summary <- cor_summary[cor_summary$variable_1 <= cor_summary$variable_2, ]

cor_summary |> 
  filter(variable_1 != variable_2) |> 
  ggplot(aes(x = correlation)) + 
  geom_density()

```


## BmlVAR posterior correlations
This only works when returning the full BmlVAR output. 

```{r}
fit_bmlvar <- sim_res_4[["results"]][[1]][["bmlvar"]][["fit_bmlvar"]][["fit_obj"]]

post_df <- posterior::as_draws_df(fit_bmlvar)

post_df |> 
  select(starts_with("Beta"))


# Extract individual indices from column names
tidy_draws <- post_df |>
  select(starts_with("Beta[")) |> 
  pivot_longer(cols = everything(), 
               names_to = "parameter", 
               values_to = "value") |>
  mutate(
    individual = as.integer(stringr::str_match(parameter, "\\[([0-9]+),")[,2]),
    row_index = as.integer(stringr::str_match(parameter, ",([0-9]+),")[,2]),
    col_index = as.integer(stringr::str_match(parameter, ",([0-9]+)\\]")[,2])
  ) |> 
  mutate(parameter = paste0("Beta[", row_index, ",", col_index, "]"))

# create person-specific correlation matrices
cor_matrices <- tidy_draws |> 
  group_by(individual, parameter) |> 
  mutate(iter = row_number()) |> 
  pivot_wider(id_cols = c(individual, iter), names_from = parameter, values_from = value) |> 
  select(!iter) |> 
  group_by(individual) |> 
  summarise(cor_matrix = list(cor(across(everything()), use = "complete.obs")), .groups = "keep")
  
# create heatmaps 
# Open a PDF device
pdf(file = "posterior_cor_heatmap.pdf", width = 8, height = 10)
  
  # Loop over each pair of matrices
  for (i in 1:75) {

    cor_mat <- cor_matrices[i, 2][[1]][[1]]

    cor_df <- reshape2::melt(cor_mat)
    
    # Generate the heatmap
    p <- ggplot(cor_df, aes(x = Vasim_res_4, y = Var2, fill = value)) +
      geom_tile() +
      scale_fill_gradient2(low = "darkblue", mid = "white", high = "darkred", midpoint = 0) +
      # plot the numerical value
      geom_text(aes(label = round(value, 2)), color = "black", size = 3) +
      labs(title = paste("Correlation Matrix for Individual", i),
           x = "",
           y = "") +
      theme_centrality()
    
    # Print the plot to the PDF
    print(p)
  }
dev.off()
```






