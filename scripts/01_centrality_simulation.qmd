---
title: "Centrality Simulation"
format: html
---

# Background
This script contains the `SimDesign` code for the simulation study. 

We first load all relevant packages: 
```{r packages}
library(tidyverse)
library(SimDesign)
library(mlVAR)
library(graphicalVAR)
library(gimme)
library(here)
source(here::here("scripts", "00_functions.R"))
```




# Data Generation

## Data-Generating Processes

Load DGP based on estimated network structures:  
```{r}
# non-sparse Graph to simulate from
graph_nonsparse <- readRDS(here::here("data/graph_nonsparse_synth.RDS"))

# sparse DGP
graph_sparse <- readRDS(here::here("data/graph_sparse_synth.RDS"))
```



## Setting parameters

We define the conditions and the fixed parameters for the simulation.

```{r params}
# Type of DGP
dgp <- c("sparse", "dense")

# Heterogeneity
heterogeneity <- c("low", "high")

# Design Conditions
df_design <- SimDesign::createDesign(
  dgp = dgp,
  heterogeneity = heterogeneity
  )


# Simulation parameters
# Number of individuals 
n_id <- 200

# Number of variables
n_var <- 6

# Number of timepoints
n_tp <- 80

# for regression
reg_error_sd = 1

gimme_var_only = TRUE

# random effects sds
# beta_sd <- 0.1
# kappa_sd <- 0.1
# # Strength of the correlation
# hard-coded down below
# beta_reg <- c(0, 0.2, 0.4)

sim_pars <- list(
  n_id = n_id,
  n_var = n_var,
  n_tp = n_tp,
  reg_error_sd = reg_error_sd,
  # beta_sd = beta_sd,
  # kappa_sd = kappa_sd,
  graph_nonsparse = graph_nonsparse,
  graph_sparse = graph_sparse,
  gimme_var_only = gimme_var_only
)
```

Pre-compiling the Stan model
```{r precompile}
model_name <- "MLVAR_lkj_only"
# Compile model
sim_pars$mlvar_model <-
  rstan::stan_model(
    file = here::here("scripts", "models", paste0(model_name, ".stan")),
    model_name = model_name
  )

```




## Simulating Data
```{r data-generation}
sim_generate <- function(condition, fixed_objects = NULL){
  source(here::here("scripts", "00_functions.R"))

  # obtain fixed params
  SimDesign::Attach(fixed_objects)

  dgp_graph <- ifelse(condition$dgp == "sparse", 
                      "graph_sparse", 
                      "graph_nonsparse")
  beta_sd <- ifelse(condition$heterogeneity == "low",
                    0.05,
                    0.1)
  
  # scale kappa random effects w.r.t diagonal elements
  mean_diag_kappa <- mean(diag(fixed_objects[[dgp_graph]]$kappa)) 
  kappa_sd_low <- 0.05 * mean_diag_kappa
  kappa_sd_high <- 0.1 * mean_diag_kappa
  
  kappa_sd <- ifelse(condition$heterogeneity == "low",
                     kappa_sd_low,
                     kappa_sd_high)
  
  ml_sim <- sim_gvar_loop(
                     graph = fixed_objects[[dgp_graph]],
                     beta_sd = beta_sd,
                     kappa_sd = kappa_sd,
                     n_person = n_id,
                     n_time = n_tp,
                     n_node = n_var,
                     max_try = 10000,
                     listify = TRUE,
                     sparse_sim = TRUE)
  if(any(is.na(ml_sim$beta))){
    stop("Generation of Betas failed")
  }
  
  if(any(is.na(ml_sim$pcor))){
    stop("Generation of PCORs failed")
  } 
  
  # Obtain true centralities
  true_cent <- centrality_mlvar_sim(ml_sim,
                                    sim_fn = "sim_gvar_loop")

  
  # helper to only scale when sd is not 0
  scale_nonz <- function(x) {
    if (sd(x) == 0) return(x)
    return(scale(x))
  }
  
  # Extract and scale network features  
  tempdens <- unlist(true_cent$dens_temp) |> scale_nonz()
  if(sd(tempdens) == 0){
    stop("No variation in tempdens")
  }
  outstrength <- sapply(true_cent$outstrength, `[`, 1) |> scale_nonz()
  if(sd(outstrength) == 0){
    stop("No variation in outstrength")
  }
  contdens <- unlist(true_cent$dens_cont) |> scale_nonz()
  if(sd(contdens) == 0){
    stop("No variation in contdens")
  }
  
  
  # Simulate covariate with certain error
  eps_sd <- reg_error_sd

  # Simulate error
  resid_dens <- rnorm(n_id, mean = 0, sd = eps_sd)
  resid_cent <- rnorm(n_id, mean = 0, sd = eps_sd)

  # correlation matrix of true effects
  rho <- c(
          1, 0, .2, .4,
          0, 1, 0, 0,
         .2, 0, 1, 0,
         .4, 0 , 0, 1) |> matrix(4, 4, byrow = T)
  
  # cholesky decomposition of rho
  L <- chol(rho)
  
  # Generate covariates with multiple levels of correlation
  generate_covariate <- function(dens, n_id, L) {
    repeat {
      covariate <- cbind(dens, rnorm(n_id), rnorm(n_id), rnorm(n_id))
      covariate <- covariate %*% L
      if (!any(is.na(covariate))) return(covariate)
    }
  }

  # Generate covariate matrices
  covariate_temp_dens <- generate_covariate(tempdens, n_id, L)
  covariate_cont_dens <- generate_covariate(contdens, n_id, L)
  covariate_out_strength <- generate_covariate(outstrength, n_id, L)
   
  
  # Return data and true centralities
  ret_data <- list(
    data = ml_sim$data,
    beta = ml_sim$beta_l,
    kappa = ml_sim$kappa_l,
    pcor = ml_sim$pcor_l,
    covariate_temp_dens = covariate_temp_dens,
    covariate_out_strength = covariate_out_strength,
    covariate_cont_dens = covariate_cont_dens,
    true_cent = true_cent
  )
  
  return(ret_data)
  
  
}

```


# Analysis

```{r data-analysis}
sim_analyse <- function(condition, dat, fixed_objects = NULL){
  
  #--- Preparation
  SimDesign::Attach(fixed_objects)
  
  # Concatenate list of data into dataframe with id column
  df_data <- dplyr::bind_rows(purrr::map(dat$data, dplyr::as_tibble)
                              , .id = "ID") %>% 
    dplyr::mutate(ID = as.factor(ID))
  
  
  
  #--- graphicalVAR
  # Fit models
  fit_gvar <- lapply(dat$data, function(x){
    tryCatch({suppressMessages(graphicalVAR::graphicalVAR(x, 
                               nLambda = 50,
                               verbose = FALSE,
                               gamma = 0, 
                               scale = FALSE))}, error = function(e) NA)
  })
  
  if(any(is.na(fit_gvar))){
    stop("Not all GVAR models converged.")
  }
  
  # Obtain centralities, IDs nested in list
  cent_gvar <- purrr::transpose(lapply(fit_gvar, function(x){
    centrality_gvar(x)
  }))

  
  dens_temp_gvar <- unlist(cent_gvar$dens_temp)
  dens_cont_gvar <- unlist(cent_gvar$dens_cont)
  outstrength_gvar <- lapply(cent_gvar$outstrength, function(x) unname(x))
  strength_gvar <- lapply(cent_gvar$strength, function(x) unname(x))
  outstrength_gvar_first <- sapply(cent_gvar$outstrength, function(x) unname(x[1]))
  
  # Create list of subject-specific estimates
  beta_gvar <- lapply(fit_gvar, function(x){
    x$beta[,-1]
  })
  pcor_gvar <- lapply(fit_gvar, function(x){
    x$PCC
  })
  
  # Fit regression
  reg_gvar_temp_dens <- lapply(2:4, function(i) lm(dat$covariate_temp_dens[, i] ~ dens_temp_gvar))
  reg_gvar_cont_dens <- lapply(2:4, function(i) lm(dat$covariate_cont_dens[, i] ~ dens_cont_gvar))
  reg_gvar_out_strength <- lapply(2:4, function(i) lm(dat$covariate_out_strength[, i] ~ outstrength_gvar_first))
  
  #--- GIMME
  
  # Fit model
  fit_gimme <- tryCatch({gimme::gimme(dat$data,
                            ar = TRUE,
                            subgroup = TRUE,
                            plot = FALSE,
                            hybrid = FALSE,
                            groupcutoff = .75,
                            subcutoff = .75,
                            VAR = gimme_var_only)}, error = function(e) NA)
  
  
  if(any(is.na(fit_gimme))){
    stop("GIMME did not converge.")
  }
  
  # for var_only, we need to first extract the contemporaneous matrices
  if(isTRUE(gimme_var_only)){
    fit_gimme$contemp_mat <- lapply(1:length(fit_gimme$path_est_mats), function(i){
      gimme_cor_mat(fit_gimme$path_se_est, id = i, n_vars = n_var)
    }
  )
  }
  
  cent_gimme <- centrality_gimme(fit_gimme,
                                 var_only = gimme_var_only)

  # Obtain centralities
  dens_temp_gimme <- unlist(cent_gimme$dens_temp)
  dens_cont_gimme <- unlist(cent_gimme$dens_cont)
  outstrength_gimme <- lapply(cent_gimme$outstrength, function(x) unname(x))
  strength_gimme <- lapply(cent_gimme$strength, function(x) unname(x))
  outstrength_gimme_first <- sapply(cent_gimme$outstrength, function(x) unname(x[1]))
  
  # Create list of subject-specific estimates
  beta_gimme <- lapply(fit_gimme$path_est_mats, function(x){
    x[,1:n_var]
  })
  
  if(isFALSE(gimme_var_only)){
      pcor_gimme <- lapply(fit_gimme$path_est_mats, function(x){
    x[, (n_var+1):(n_var*2)]
  })
  }
  
  if(isTRUE(gimme_var_only)){
    pcor_gimme <- lapply(fit_gimme$contemp_mat, function(x){
      x
    })
  }


  # Fit regression
  reg_gimme_temp_dens <- lapply(2:4, function(i) lm(dat$covariate_temp_dens[, i] ~ dens_temp_gimme))
  reg_gimme_cont_dens <- lapply(2:4, function(i) lm(dat$covariate_cont_dens[, i] ~ dens_cont_gimme))
  reg_gimme_out_strength <- lapply(2:4, function(i) lm(dat$covariate_out_strength[, i] ~ outstrength_gimme_first))

  # #--- frequentist mlVAR

  # Fit model
  fit_mlvar <- tryCatch({suppressMessages(mlVAR::mlVAR(df_data,
                            vars = paste0("V", seq(1:n_var)),
                            idvar = "ID",
                            estimator = "lmer",
                            contemporaneous = "correlated",
                            temporal = "correlated",
                            nCores = 1,
                            scale = FALSE))}, error = function(e) NA)
  if(any(is.na(fit_mlvar))){
    stop("mlVAR did not converge.")
  }
  
  

  # Obtain centralities
  cent_mlvar <- centrality_mlvar(fit_mlvar)
  dens_temp_mlvar <- unlist(cent_mlvar$dens_temp)
  dens_cont_mlvar <- unlist(cent_mlvar$dens_cont)
  outstrength_mlvar <- lapply(cent_mlvar$outstrength, function(x) unname(x))
  strength_mlvar <- lapply(cent_mlvar$strength, function(x) unname(x))
  outstrength_mlvar_first <- sapply(cent_mlvar$outstrength, function(x) unname(x[1]))
  
  # Create list of subject-specific estimates
  beta_mlvar <- lapply(1:n_id, function(i){
    t(mlVAR::getNet(fit_mlvar,
                  subject = i,
                  type = "temporal",
                  nonsig = "show"))
  })
  pcor_mlvar <- lapply(1:n_id, function(i){
    mlVAR::getNet(fit_mlvar,
                  subject = i,
                  type = "contemporaneous",
                  nonsig = "show")
  })
  
  # # Calculate fixed effects adjacency matrix
  adj_mat_beta <- ifelse(
    t(mlVAR::getNet(fit_mlvar,
       type = "temporal",
       nonsig = "hide") != 0, 1, 0))
  adj_mat_pcor <- ifelse(
    mlVAR::getNet(fit_mlvar,
       type = "contemporaneous",
       nonsig = "hide") != 0, 1, 0)

  # set effects to zero
  beta_mlvar <- lapply(beta_mlvar, function(i){
    i * adj_mat_beta
  })
  pcor_mlvar <- lapply(pcor_mlvar, function(i){
    i * adj_mat_pcor
  })

  # Fit regression
  reg_mlvar_temp_dens <- lapply(2:4, function(i) lm(dat$covariate_temp_dens[, i] ~ dens_temp_mlvar))
  reg_mlvar_cont_dens <- lapply(2:4, function(i) lm(dat$covariate_cont_dens[, i] ~ dens_cont_mlvar))
  reg_mlvar_out_strength <- lapply(2:4, function(i) lm(dat$covariate_out_strength[, i] ~ outstrength_mlvar_first))
  
  
  # 
  #--- Bayesian mlVAR
  # indicators for partial correlations
  idx_rho <- upper.tri(matrix(1, n_var, n_var, byrow = F)) %>% 
      c() %>% 
      which(.)
  
  reg_data <- cbind(
    dat$covariate_temp_dens[, 2:4],
    dat$covariate_cont_dens[, 2:4],
    dat$covariate_out_strength[, 2:4]
  )
  Y <- df_data %>% 
    dplyr::select(-"ID") %>% 
    as.matrix()
  
  # Prepare stan data
  stan_data <- list(
    K = n_var,
    I = n_id,
    P = 9,   # number of regression outcomes
    N_total = n_id * n_tp,
    n_t = rep(n_tp, n_id),
    n_pc = n_var * (n_var - 1) / 2,
    idx_rho = array(idx_rho, dim = length(idx_rho)),
    Y = Y,
    reg_covariate = reg_data
  )
  
  
  fit_bmlvar <- rstan::sampling(
  object = fixed_objects$mlvar_model,
  pars = vars(contains("raw")),
  include = FALSE,
  data = stan_data,
  seed = 2023,
  chains = 3,
  cores = 1,
  warmup = 300,
  iter = 500,
  init = 0,
  control = list(adapt_delta = 0.8),
  verbose = FALSE
  )
  
  if(!inherits(fit_bmlvar, "stanfit")){
    stop("BmlVAR model failed.")
  }
  
  # Transpose beta matrices for later summaries
  # in the DGP, cols represent lagged vars
  # but in BmlVAR, rows represent lagged vars
  ests_bmlvar <- extract_all_estimates(fit_bmlvar,
                                       n_id = n_id, 
                                       n_var = n_var, 
                                       transpose_beta = TRUE)
  
  # Obtain centralities
  dens_temp_bmlvar <- ests_bmlvar$tempdens_est$median
  dens_cont_bmlvar <- ests_bmlvar$contdens_est$median
  # Obtain centralities
  dens_temp_bmlvar <- ests_bmlvar$tempdens_est$median
  dens_cont_bmlvar <- ests_bmlvar$contdens_est$median
  outstrength_bmlvar <- ests_bmlvar$outstrength_est$median
  strength_bmlvar <- ests_bmlvar$pcor_centrality_est$median
  outstrength_bmlvar_first <- sapply(ests_bmlvar$outstrength_est$median, function(x) unname(x[1]))

  # Obtain regression coefficients
  reg_bmlvar <- list(
    regression_intercept = ests_bmlvar$regression_intercept_est, 
    regression_slope = ests_bmlvar$regression_slope_est)
  
  # save summary 
  summary_bmlvar <- rstan::summary(fit_bmlvar)
  
  # convergence diagnostics
  rhat_bmlvar_tmp <- summary_bmlvar$summary %>% as.data.frame() %>% pull(Rhat)
  rhat_bmlvar_tmp <- rhat_bmlvar_tmp[!is.nan(rhat_bmlvar_tmp)]
  rhat_bmlvar_mean <- mean(rhat_bmlvar_tmp, na.rm = TRUE)
  rhat_bmlvar_11 <- sum(rhat_bmlvar_tmp > 1.1)/length(rhat_bmlvar_tmp)
  divtrans_bmlvar <- rstan::get_num_divergent(fit_bmlvar)
  
  #--- Return Results
  # Also return true centralities for comparison later
  ret_results <- list(
    gvar = list(
      fit_gvar = list(
        beta = beta_gvar,
        pcor = pcor_gvar),
      dens_temp = dens_temp_gvar,
      dens_cont = dens_cont_gvar,
      outstrength = outstrength_gvar,
      strength = strength_gvar,
      reg_tempdens = reg_gvar_temp_dens,
      reg_contdens = reg_gvar_cont_dens,
      reg_outstrength = reg_gvar_out_strength
    ),
    gimme = list(
      fit_gimme = list(
        beta = beta_gimme,
        pcor = pcor_gimme
      ),
      dens_temp = dens_temp_gimme,
      dens_cont = dens_cont_gimme,
      outstrength = outstrength_gimme,
      strength = strength_gimme,
      reg_tempdens = reg_gimme_temp_dens,
      reg_contdens = reg_gimme_cont_dens,
      reg_outstrength = reg_gimme_out_strength
    ),
    mlvar = list(
      fit_mlvar = list(
        beta = beta_mlvar,
        pcor = pcor_mlvar),
      dens_temp = dens_temp_mlvar,
      dens_cont = dens_cont_mlvar,
      outstrength = outstrength_mlvar,
      strength = strength_mlvar,
      reg_tempdens = reg_mlvar_temp_dens,
      reg_contdens = reg_mlvar_cont_dens,
      reg_outstrength = reg_mlvar_out_strength
    ),
    bmlvar = list(
      fit_bmlvar = list(
        beta = ests_bmlvar$beta_est$median,
        pcor = ests_bmlvar$pcor_est$median
      ),
      dens_temp = dens_temp_bmlvar,
      dens_cont = dens_cont_bmlvar,
      outstrength = outstrength_bmlvar,
      strength = strength_bmlvar,
      reg_bmlvar = reg_bmlvar,
      ests_bmlvar = ests_bmlvar,
      summary_bmlvar = summary_bmlvar,
      rhat_bmlvar_mean = rhat_bmlvar_mean,
      rhat_bmlvar_11 = rhat_bmlvar_11,
      divtrans_bmlvar = divtrans_bmlvar
    ),
    true_cent = dat$true_cent,
    data = dat$data,
    beta = dat$beta,
    kappa = dat$kappa,
    pcor = dat$pcor
  )
  return(ret_results)
  
}

```



# Summary

To note about data structure:
- GVAR fit: cols as lagged, also in the DGP
- mlVAR fit: rows as lagged, cols as contemp --> now transposed
- gimme fit: cols as lagged
- bmlVAR fit: different data structure, but uses rows as lagged


However, with the new sim function, we do not transpose anymore! We simulate from `graphicalVARsim`, so in the true DGP, columns represent the nodes of origin. 

```{r summarize}
sim_summarise <- function(condition, results, fixed_objects = NULL){
  
  #--- Preparation
  SimDesign::Attach(fixed_objects)
  ret <- list()
  
  #--- Parameter recovery  
  # IMPORTANT: Keep in mind structure of sim object (rows vs. cols)
  #-- RMSE
  summary_calc <- function(results, method, fit, measure, func) {
  sapply(seq_along(results), function(i){
    if(is.null(results[[i]][[method]][[fit]])){
      return(NA)
    } 
    else{
      unlist(func(results[[i]][[method]][[fit]][[measure]], results[[i]][[measure]]))
    }
  })
}

  
  methods <- c("gvar", "gimme", "mlvar", "bmlvar")
  measures <- c("beta", "pcor")
  funcs <- list("rmse" = rmse_mean_list, 
                "mse" = mse_mean_list, 
                "bias" = bias_mean_list)
  
  # Loop to get summaries and save them into the ret list
  rmse_list <- list()
  mse_list <- list()
  for (method in methods) {
      for (measure in measures) {
        for (func_name in names(funcs)) {
          result_name <- paste(func_name, measure, method, sep = "_")
          calc_list <- summary_calc(
            results, 
            method, 
            paste0("fit_", method), 
            measure, 
            funcs[[func_name]])
          mean_tmp <- colMeans(apply(as.matrix(calc_list), c(1,2), as.numeric))
          ret[[paste0(result_name, "_mean")]] <- mean(mean_tmp)
          if(func_name == "rmse"){
            # calculate MSE, needed for MCSE of RMSE
            mse_tmp <- summary_calc(
            results, 
            method, 
            paste0("fit_", method), 
            measure, 
            funcs[["mse"]])
            mse_mean_tmp <- mean(colMeans(apply(as.matrix(mse_tmp), c(1,2), as.numeric)))
            ret[[paste0(result_name, "_mcse")]] <- sqrt(stats::var(mean_tmp) / 
                                                          (4 * n_rep * mse_mean_tmp))
          }
          else if(func_name == "mse"){
            ret[[paste0(result_name, "_mcse")]] <- sqrt(stats::var(mean_tmp) / n_rep)
          }
          else if(func_name == "bias"){
            ret[[paste0(result_name, "_mcse")]] <- sqrt(stats::var(mean_tmp) / n_rep)
          }
        }
      }
  }

  
    
  #--- Centrality
  #-- Rank-Order between individuals
  calc_correlation <- function(results, method, measure) {
  sapply(seq_along(results), function(i){
    if(is.null(results[[i]][[method]][[paste0("fit_", method)]])){
      return(NA)
    } 
    else{
      stats::cor(results[[i]][[method]][[paste0("dens_", measure)]], 
                 unlist(results[[i]]$true_cent[[paste0("dens_", measure)]]), 
                 method = "spearman")
    }
  })
  }
  
  # Bootstrap the MCSE for the rank correlation
  bootstrap_rankcor <- function(data, n_boot){
    bootstrap_res <- vector("numeric", n_boot)
    for(i in 1:n_boot){
      ind <- sample(1:n_boot, replace = TRUE)
      bootstrap_res[i] <- mean(data[ind], na.rm = TRUE)
    }
      sd(bootstrap_res, na.rm = TRUE)
  }
  
  measures <- c("temp", "cont")
  for (method in methods) {
    for (measure in measures) {
      result_name <- paste("rankcor", measure, method, sep = "_")
      calc_list <- calc_correlation(
        results = results,
        method = method,
        measure = measure)
      mean_tmp <- mean(calc_list)
      sd_tmp <- bootstrap_rankcor(calc_list, 1000)
      ret[[paste0(result_name, "_mean")]] <- mean_tmp
      ret[[paste0(result_name, "_mcse")]] <- sd_tmp
    }
  }
  
    
  #-- Most central within individuals
  calc_most_cent_ident <- function(results, method, measure) {
    sapply(seq_along(results), function(i){
      if(is.null(results[[i]][[method]][paste0("fit_", method)])){
        return(NA)
      } 
      else{
        mci <- most_cent_ident(results[[i]][[method]][[measure]], 
                              results[[i]]$true_cent[[measure]])
        colSums(matrix(unlist(mci), 
                      nrow = n_id, 
                      byrow = FALSE))/n_id
      }
    })
  }
  
  measures <- c("outstrength", "strength")
  
  for(method in methods){
    for(measure in measures){
      calc_list <- calc_most_cent_ident(
        results = results, 
        method = method, 
        measure = measure)
        mean_tmp <- mean(calc_list, na.rm = TRUE) 
        mcse_tmp <- sqrt(mean_tmp * (1 - mean_tmp) / n_rep)
      if(measure == "outstrength"){
        ret[[paste0("mostcent_beta_", method, "_mean")]] <- mean_tmp
        ret[[paste0("mostcent_beta_", method, "_mcse")]] <- mcse_tmp
        
      } else if(measure == "strength"){
        ret[[paste0("mostcent_pcor_", method, "_mean")]] <- mean_tmp
        ret[[paste0("mostcent_pcor_", method, "_mcse")]] <- mcse_tmp
      }
    }
  }
  
  

  
  
  #--- Regression
  #-- Power
  regression_power <- function(results, 
                               method, 
                               measure,
                               true_coef = c(0,.2,.4),
                               lm_beta = TRUE) {
  sapply(seq_along(results), function(i){
    if(is.null(results[[i]][[method]][[paste0("reg_", measure)]])){
      return(NA)
    } 
    else{
      reg_pvals <- sapply(results[[i]][[method]][[paste0("reg_", measure)]],
                          function(x){
                            if(isTRUE(lm_beta)){
                              res <- summary(lm.beta::lm.beta(x))$coefficients
                              res[2,5]
                            } else{
                              res <- summary(x)$coefficients
                              res[2,4]
                            }})

      # Calculate Empirical detection rate/power
      ifelse(reg_pvals < .05, 1, 0)
    }
  })
  }


  #-- RMSE
  true_coef <- c(0, .2, .4)
  regression_rmse <- function(results, 
                              method, 
                              measure,
                              true_coef = c(0,.2,.4),
                              lm_beta = TRUE,
                              rmse = TRUE) {
  sapply(seq_along(results), function(i){
    if(is.null(results[[i]][[method]][[paste0("reg_", measure)]])){
      return(NA)
    } 
    else{
      reg_coefs <- sapply(results[[i]][[method]][[paste0("reg_", measure)]],
                          function(x){
                            if(isTRUE(lm_beta)){
                              lm.beta::lm.beta(x)$standardized.coefficients
                            } else{
                              x$coefficients
                            }})[2,]   # 2nd row -> beta coef
      # Calculate RMSE
      if(isTRUE(rmse)){
        sqrt( (reg_coefs - true_coef )^2 )
      } else{
        (reg_coefs - true_coef)^2
      }
      
      }
  })
  }
  
  
  # exclude bmlvar because of its different data structure
  methods <- c("gvar", "mlvar", "gimme")
  measures <- c("tempdens", "contdens", "outstrength")
  summaries <- c("rmse", "mse")
  
  # rmse_list <- list()

  for (method in methods) {
      for (measure in measures) {
        for (summary in summaries) {
          # Calculate RMSE/MSE
          result_name_rmse <- paste(summary, "reg", measure, method, sep = "_")
          calc_list <- regression_rmse(
            results = results, 
            method = method, 
            measure = measure,
            rmse = ifelse(summary == "rmse", TRUE, FALSE))
          mean_tmp <- rowMeans(calc_list, na.rm = TRUE)
          # bit of a hack to add the names for the different correlation
          # levels
          names(mean_tmp) <- paste0(summary, 
                                   "_reg",
                                   c(0, 2, 4),
                                   "_",
                                   measure,
                                   "_",
                                   method,
                                   "_mean")
          ret[[paste0(result_name_rmse, "_mean")]] <- mean_tmp
          if(func_name == "rmse"){
            # calculate MSE
            mse_tmp <- regression_rmse(
            results, 
            method, 
            measure,
            rmse = FALSE)
            mse_mean_tmp <- rowMeans(mse_tmp, na.rm = TRUE)
            # names(mean_tmp) <- paste0(summary, 
            #                        "_reg",
            #                        c(0, 2, 4),
            #                        "_",
            #                        measure,
            #                        "_",
            #                        method,
            #                        "_mean")
            mcse_tmp <- sqrt (apply(calc_list, 1, var, na.rm = TRUE) / (4*n_rep*mse_mean_tmp))
            names(mcse_tmp) <- paste0(summary, 
                                   "_reg",
                                   c(0, 2, 4),
                                   "_",
                                   measure,
                                   "_",
                                   method,
                                   "_mcse")
            ret[[paste0(result_name_rmse, "_mcse")]] <- mcse_tmp
          }
          else if(func_name == "mse"){
            mcse_tmp <- sqrt(
              apply(calc_list, 1, var, na.rm = TRUE) / n_rep)
            names(mcse_tmp) <- paste0(summary, 
                                   "_reg",
                                   c(0, 2, 4),
                                   "_",
                                   measure,
                                   "_",
                                   method,
                                   "_mcse")
            ret[[paste0(result_name_rmse, "_mcse")]] <- mcse_tmp
          }
          # Calculate Power
          result_name_power <- paste("power", "reg", measure, method, sep = "_")
          calc_list_pwr <- regression_power(
            results = results, 
            method = method, 
            measure = measure)
          pwr_mean <- rowMeans(calc_list_pwr, na.rm = TRUE)
          names(pwr_mean) <- paste0("power", 
                                   "_reg",
                                   c(0, 2, 4),
                                   "_",
                                   measure,
                                   "_",
                                   method,
                                   "_mean")
          ret[[paste0(result_name_power, "_mean")]] <- pwr_mean
          pwr_mcse_tmp <- sqrt(
            pwr_mean * (1 - pwr_mean) / n_rep)
          names(pwr_mcse_tmp) <- paste0("power", 
                                   "_reg",
                                   c(0, 2, 4),
                                   "_",
                                   measure,
                                   "_",
                                   method,
                                   "_mcse")
          ret[[paste0(result_name_power, "_mcse")]] <- pwr_mcse_tmp
        }
      }
  }
  
  # Summary for bmlvar
  method <- "bmlvar"
  regression_rmse_bmlvar <- function(
                              results, 
                              method = "bmlvar", 
                              true_coef = c(0,.2,.4),
                              # lm_beta = TRUE,
                              rmse = TRUE) {
  sapply(seq_along(results), function(i){
    if(is.null(results[[i]][[method]][["reg_bmlvar"]])){
      return(NA)
    } 
    else{
      reg_coefs <- results[[i]][[method]][["reg_bmlvar"]][["regression_slope"]][["median"]]
      # Have them all in one vector
      # thus need to repeat the true_coefs 
      true_coef_all <- rep(true_coef, 3)

      # Calculate RMSE
      if(isTRUE(rmse)){
        sqrt( (reg_coefs - true_coef )^2 )
      } else{
        (reg_coefs - true_coef)^2
      }
      
      }
  })
  }
  
  regression_power_bmlvar <- function(
                              results, 
                              method = "bmlvar", 
                              measure,
                              oneside = TRUE){
  sapply(seq_along(results), function(i){
    if(is.null(results[[i]][[method]][["reg_bmlvar"]])){
      return(NA)
    } 
    else{
      ci_twoside <- results[[i]][[method]][["reg_bmlvar"]][["regression_slope"]][["ci_95_l"]]
      ci_oneside <- results[[i]][[method]][["reg_bmlvar"]][["regression_slope"]][["ci_oneside"]]
      if(isTRUE(oneside)){
        ifelse(ci_oneside > 0, 1, 0)
      } else{
        ifelse(ci_twoside > 0, 1, 0)
      
    }
  }
  })
  }
  
  # Apply the functions
  calc_rmse <- regression_rmse_bmlvar(
    results = results, 
    method = "bmlvar", 
    rmse = TRUE)
  calc_mse <- regression_rmse_bmlvar(
    results = results, 
    method = "bmlvar", 
    rmse = FALSE)
  calc_pwr_oneside <- regression_power_bmlvar(
    results = results, 
    method = "bmlvar",
    oneside = FALSE)
  calc_pwr_twoside <- regression_power_bmlvar(
    results = results, 
    method = "bmlvar",
    oneside = FALSE)
  
  # Calculate mean
  mean_rmse <- rowMeans(calc_rmse, na.rm = TRUE)
  names(mean_rmse) <- paste0("rmse", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mean")
  mean_mse <- rowMeans(calc_mse, na.rm = TRUE)
  names(mean_mse) <- paste0("mse", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mean")
  mean_pwroneside <- rowMeans(calc_pwr_oneside, na.rm = TRUE)
  names(mean_pwroneside) <- paste0("poweroneside", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mean")
  mean_pwrtwoside <- rowMeans(calc_pwr_twoside, na.rm = TRUE)
  names(mean_pwrtwoside) <- paste0("powertwoside", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mean")
  ret[["mean_rmse"]] <- mean_rmse
  ret[["mean_mse"]] <- mean_mse
  ret[["mean_pwroneside"]] <- mean_pwroneside
  ret[["mean_pwrtwoside"]] <- mean_pwrtwoside
  
  # calculate mcse
  mcse_rmse <- sqrt(
    mean_rmse * (1 - mean_rmse) / n_rep)
  names(mcse_rmse) <- paste0("rmse", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mcse")
  mcse_mse <- sqrt(
    mean_mse * (1 - mean_mse) / n_rep)
  names(mcse_mse) <- paste0("mse", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mcse")
  mcse_pwroneside <- sqrt(
    mean_pwroneside * (1 - mean_pwroneside) / n_rep)
  names(mcse_pwroneside) <- paste0("poweroneside", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mcse")
  mcse_pwrtwoside <- sqrt(
    mean_pwrtwoside * (1 - mean_pwrtwoside) / n_rep)
  names(mcse_pwrtwoside) <- paste0("powertwoside", 
                             "_reg",
                             c(0, 2, 4),
                             "_",
                             rep(measures, each = 3),
                             "_",
                             "bmlvar",
                             "_mcse")
  ret[["mcse_rmse"]] <- mcse_rmse
  ret[["mcse_mse"]] <- mcse_mse
  ret[["mcse_pwroneside"]] <- mcse_pwroneside
  ret[["mcse_pwrtwoside"]] <- mcse_pwrtwoside
  
  
  #--- Return
  ret$bmlvar_diagnostics <- list()
  ret$bmlvar_diagnostics$rhat_bmlvar_mean <- mean(sapply(results, function(x){
     x$bmlvar$rhat_bmlvar_mean}))
  ret$bmlvar_diagnostics$rhat_bmlvar_mean <- mean(sapply(results, function(x){
     x$bmlvar$rhat_bmlvar_11}))
  ret$bmlvar_diagnostics$divtrans_bmlvar <- lapply(results, function(x){
    x$bmlvar$divtrans_bmlvar})
  ret_vec <- unlist(ret, use.names = TRUE)
  return(ret_vec)
  
  
  
  
}


```


# Executing Simulation

```{r run-sim}
# For testing
df_design_test <- df_design[2,]
sim_pars$n_id <- 25
sim_pars$n_var <- 6
n_var <- 6
n_id <- 25
# sim_pars$graph_sparse$beta <- sim_pars$graph_sparse$beta[1:4,1:4]
# sim_pars$graph_sparse$pcor <- sim_pars$graph_sparse$pcor[1:4,1:4]
# sim_pars$graph_sparse$kappa <- sim_pars$graph_sparse$kappa[1:4,1:4]
# sim_pars$graph_nonsparse$beta <- sim_pars$graph_nonsparse$beta[1:4,1:4]
# sim_pars$graph_nonsparse$pcor <- sim_pars$graph_nonsparse$pcor[1:4,1:4]
# sim_pars$graph_nonsparse$kappa <- sim_pars$graph_nonsparse$kappa[1:4,1:4]


n_rep <- 2
library(future)
library(progressr)
future::plan(multisession, workers = n_rep)
# handlers("rstudio")
# handlers('cli')

# started 2024-04-19 ~11:20

sim_results <- SimDesign::runSimulation(
                                    design = df_design, 
                                    replications = n_rep, 
                                    generate = sim_generate, 
                                    analyse = sim_analyse, 
                                    summarise = sim_summarise,
                                    fixed_objects = sim_pars,
                                    parallel = "future",
                                    max_errors = 2,
                                    packages = c("tidyverse", 
                                                 "gimme",
                                                 "mlVAR",
                                                 "graphicalVAR",
                                                 "lm.beta",
                                                 "bayestestR",
                                                 "posterior",
                                                 "rstan",
                                                 "Rcpp"),
                                    # save_results = TRUE
                                    # ncores = 1
                                    debug = "generate"
                                    # filename = "centrality-simulation.rds",
                                    # save_seeds = TRUE
                                    )

plan(sequential)

SimClean()
saveRDS(sim_results, file = here("output/pilot_sim_results_clean_2104.RDS"))

```

# Visualization

TEMPORARY: Remove all Rhat columns, way too many in the pilot sim_results
```{r}
sim_results <- readRDS(here("output/pilot_sim_results_clean_2104.RDS"))
sim_res_cut <- sim_results %>%
  select(-contains("rhat")) %>%
  select(-contains("divtrans"))

# sim_res_cut <- sim_results

```




Prepare dataframe 
```{r}
sr_edit <- sim_res_cut %>% 
  mutate(dgp = factor(dgp, levels = c("dense", "sparse")),
         heterogeneity = factor(heterogeneity, levels = c("low", "high"))) %>% 
  # remove "reg_" from all column names
  rename_with(~str_remove(., "reg_")) %>% 
  # remove everything before a "." in the column names
  rename_with(~str_remove(., ".*\\.")) %>% 
  dplyr::select(-c("REPLICATIONS", "SIM_TIME", "RAM_USED", "SEED", "COMPLETED", "WARNINGS")) %>% 
  # pivot longer except conditions cols
  pivot_longer(cols = -c("dgp", "heterogeneity"), 
               names_to = "measure", 
               values_to = "value") %>% 
  mutate(measure = str_replace(measure, "power_reg", "powerreg"),
         measure = str_replace(measure, "powertwoside_reg", "powertwosidereg"),
         measure = str_replace(measure, "poweroneside_reg", "poweronesidereg"),
         measure = str_replace(measure, "rmse_reg", "rmsereg"),
         measure = str_replace(measure, "mse_reg", "msereg")) %>%
  separate_wider_delim(measure, 
                       delim = "_",
                       names = c("pm", "outcome", "method", "summary")) %>% 
  mutate(method = case_when(
    method == "gvar" ~ "GVAR",
    method == "gimme" ~ "GIMME",
    method == "mlvar" ~ "mlVAR",
    method == "bmlvar" ~ "BmlVAR"
  )) %>%
  # treat method as factor and order 
  mutate(method = factor(method, levels = c("GVAR", "GIMME", "mlVAR", "BmlVAR"))) %>%
  group_by(dgp, heterogeneity, pm, outcome, method) %>%
  pivot_wider(names_from = summary, values_from = value) %>% 
  ungroup()



```



Prepare different colors and settings for visualization: 
```{r viz-prep}
meth_colors <- ggokabeito::palette_okabe_ito()[c(5, 1, 2, 3)]

```






## Point Estimates

Plot point estimate recovery (RMSE), not directly relevant for the manuscript, but maybe helpful to understand the overall performance of the different methods.

```{r viz-point-estimates}
plot_mse <- sr_edit %>% 
  mutate(mcse = ifelse(is.na(mcse), 0, mcse)) %>%
  mutate(outcome = case_when(
    outcome == "beta" ~ "Temporal",
    outcome == "pcor" ~ "Contemporaneous"
  )) %>%
  mutate(heterogeneity = case_when(
    heterogeneity == "low" ~ "Low\nHeterogeneity",
    heterogeneity == "high" ~ "High\nHeterogeneity"
  )) %>%
  mutate(dgp = case_when(
    dgp == "dense" ~ "Non-Sparse",
    dgp == "sparse" ~ "Sparse"
  )) %>%
  filter(pm == "mse") %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method
             )) +
  # add horizontal line between methods
  geom_vline(colour = "#F3F4F5", xintercept = seq(1.5, 4, 1))+
  geom_errorbar(aes(ymin = mean - 1*mcse,
                            ymax = mean + 1*mcse),
                        width = .8,
                 position = position_dodge(0.7),
                 show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(-0.15,0.1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none")+
  labs(title = "",
       x = "Method",
       colour = "Method",
       y = "MSE of Network Estimation")

plot_mse

```

Plot Bias:

```{r viz-bias}
plot_bias <- sr_edit %>% 
  mutate(mcse = ifelse(is.na(mcse), 0, mcse)) %>%
  mutate(outcome = case_when(
    outcome == "beta" ~ "Temporal",
    outcome == "pcor" ~ "Contemporaneous"
  )) %>%
  mutate(heterogeneity = case_when(
    heterogeneity == "low" ~ "Low\nHeterogeneity",
    heterogeneity == "high" ~ "High\nHeterogeneity"
  )) %>%
  mutate(dgp = case_when(
    dgp == "dense" ~ "Non-Sparse",
    dgp == "sparse" ~ "Sparse"
  )) %>%
  filter(pm == "bias") %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method
             )) +
  # add horizontal line between methods
  geom_vline(colour = "#F3F4F5", xintercept = seq(1.5, 4, 1))+
  geom_errorbar(aes(ymin = mean - 1*mcse,
                            ymax = mean + 1*mcse),
                        width = .8,
                 position = position_dodge(0.7),
                 show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(-0.1,0.1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none")+
  labs(title = "",
       x = "Method",
       colour = "Method",
       y = "Bias of Network Estimation")

plot_bias
```




## Centrality

### Plot most central identical 

```{r viz-most-central}
plot_mostcentral <- sr_edit %>% 
  # if mcse is missing, set to 0
  mutate(mcse = ifelse(is.na(mcse), 0, mcse)) %>%
  mutate(outcome = case_when(
    outcome == "beta" ~ "Temporal",
    outcome == "pcor" ~ "Contemporaneous"
  )) %>%
  mutate(heterogeneity = case_when(
    heterogeneity == "low" ~ "Low\nHeterogeneity",
    heterogeneity == "high" ~ "High\nHeterogeneity"
  )) %>%
  mutate(dgp = case_when(
    dgp == "dense" ~ "Non-Sparse",
    dgp == "sparse" ~ "Sparse"
  )) %>%
  filter(pm == "mostcent") %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method
             )) +
  # add horizontal line between methods
  geom_vline(colour = "#F3F4F5", xintercept = seq(1.5, 4, 1))+
  geom_errorbar(aes(ymin = mean - 1*mcse,
                            ymax = mean + 1*mcse),
                        width = .8,
                 position = position_dodge(0.7),
                 show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1.1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none")+
  labs(title = "",
       x = "Method",
       colour = "Method",
       y = "Proportion of Correct Central Nodes")

ggsave("plot_mostcentral_mock.svg", plot_mostcentral, height = 5, width = 9,
       path = here::here("figures/"), device = "svg")

plot_mostcentral

```


### Plot rank correlation of centrality measures

```{r viz-rank-correlation}
plot_rankcor <- sr_edit %>% 
  # if mcse is missing, set to 0
  mutate(mcse = ifelse(is.na(mcse), 0, mcse)) %>%
  # uselessly used temp and cont instead of beta and pcor here
  mutate(outcome = case_when(
    outcome == "temp" ~ "Temporal",
    outcome == "cont" ~ "Contemporaneous"
  )) %>%
  mutate(heterogeneity = case_when(
    heterogeneity == "low" ~ "Low\nHeterogeneity",
    heterogeneity == "high" ~ "High\nHeterogeneity"
  )) %>%
  mutate(dgp = case_when(
    dgp == "dense" ~ "Non-Sparse",
    dgp == "sparse" ~ "Sparse"
  )) %>%
  filter(pm == "rankcor") %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method
             )) +
  # add horizontal line between methods
  geom_vline(colour = "#F3F4F5", xintercept = seq(1.5, 4, 1))+
  geom_errorbar(aes(ymin = mean - 1*mcse,
                            ymax = mean + 1*mcse),
                        width = .8,
                 position = position_dodge(0.7),
                 show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1.1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none")+
  labs(title = "",
       x = "Method",
       colour = "Method",
       y = "Centrality Rank Correlation")


plot_rankcor


``` 

Here seems to be something wrong

## Regression

Need to find a way to nest the different strengths of regression coefficient

### Plot power of regression
Prep data
```{r viz-regression-power-prep}
# Split data set into three based on true effect
power_list <- sr_edit %>% 
  filter(!str_detect(pm, "poweroneside")) %>% 
  mutate(pm = str_replace(pm, "powertwoside", "power")) %>% 
  filter(str_detect(pm, "power")) %>% 
  mutate(outcome = case_when(
    outcome == "tempdens" ~ "Temporal\nDensity",
    outcome == "contdens" ~ "Contemporaneous\nDensity",
    outcome == "outstrength" ~ "Temporal\nOutstrength"
  )) %>%
  mutate(heterogeneity = case_when(
    heterogeneity == "low" ~ "Low\nHeterogeneity",
    heterogeneity == "high" ~ "High\nHeterogeneity"
  )) %>%
  mutate(dgp = case_when(
    dgp == "dense" ~ "Non-Sparse",
    dgp == "sparse" ~ "Sparse"
  )) %>%
  # split pm into two columns, take last number into new column
  separate_wider_delim(pm, delim = "reg", names = c("pm", "true_effect")) %>% 
  # split data set into list based on true effect
  split(.$true_effect)
```


Create plot under the Null
```{r viz-regression-power0}
plot0 <- power_list[[1]] %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method,
             fill = method,
             group = method)) +
  geom_errorbar(aes(ymin = mean - 1*mcse,
                    ymax = mean + 1*mcse),
                width = .8,
                position = position_dodge(0.7),
                show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,.3)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none",
        strip.text.x.top = ggplot2::element_text(size = rel(0.85)),
        ggh4x.facet.nestline = element_line(colour = "#6d6d6e"))+
  labs(title = "",
       x = "",
       colour = "Method",
       y = "False-Positive Rate")
plot0

```

Create plot for .2 
```{r viz-regression-power2}
plot2 <- power_list[[2]] %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method,
             fill = method,
             group = method)) +
  geom_errorbar(aes(ymin = mean - 1*mcse,
                    ymax = mean + 1*mcse),
                width = .8,
                position = position_dodge(0.7),
                show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1.1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none",
        strip.text.x.top = ggplot2::element_blank())+
  labs(title = "",
       x = "",
       colour = "Method",
       y = "Power")


```


Create plot for .4
```{r viz-regression-power4}
plot4 <- power_list[[3]] %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method,
             fill = method,
             group = method)) +
  geom_errorbar(aes(ymin = mean - 1*mcse,
                    ymax = mean + 1*mcse),
                width = .8,
                position = position_dodge(0.7),
                show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1.1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none",
        strip.text.x.top = ggplot2::element_blank())+
  labs(title = "",
       x = "Method",
       colour = "Method",
       y = "Power")
plot4
```


Combine them with patchwork
```{r viz-regression-power-combined}
plot_power_combined <- cowplot::plot_grid(plot0, plot2, plot4, ncol = 1,
                                          labels = c("True Effect: 0", 
                                                     "True Effect: 0.2",
                                                     "True Effect: 0.4"))

ggsave("plot_power_combined_mock.svg", plot_power_combined, height = 12, width = 16,
       path = here::here("figures/"), device = "svg")

plot_power_combined

```


### Plot RMSE of regression

```{r viz-regression-rmse}
rmse_list <- sr_edit %>% 
  filter(str_detect(pm, "rmsereg")) %>% 
  mutate(outcome = case_when(
    outcome == "tempdens" ~ "Temporal\nDensity",
    outcome == "contdens" ~ "Contemporaneous\nDensity",
    outcome == "outstrength" ~ "Temporal\nOutstrength"
  )) %>%
  mutate(heterogeneity = case_when(
    heterogeneity == "low" ~ "Low\nHeterogeneity",
    heterogeneity == "high" ~ "High\nHeterogeneity"
  )) %>%
  mutate(dgp = case_when(
    dgp == "dense" ~ "Non-Sparse",
    dgp == "sparse" ~ "Sparse"
  )) %>%
  # split pm into two columns, take last number into new column
  separate_wider_delim(pm, delim = "reg", names = c("pm", "true_effect")) %>% 
  # split data set into list based on true effect
  split(.$true_effect)
```


Create plot under the Null
```{r viz-regression-power0}
plot0_rmsereg <- rmse_list[[1]] %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method,
             fill = method,
             group = method)) +
  geom_errorbar(aes(ymin = mean - 1*mcse,
                    ymax = mean + 1*mcse),
                width = .8,
                position = position_dodge(0.7),
                show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none",
        strip.text.x.top = ggplot2::element_text(size = rel(0.85)),
        ggh4x.facet.nestline = element_line(colour = "#6d6d6e"))+
  labs(title = "",
       x = "",
       colour = "Method",
       y = "RMSE")


```

Create plot for .2 
```{r viz-regression-power2}
plot2_rmsereg <- rmse_list[[2]] %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method,
             fill = method,
             group = method)) +
  geom_errorbar(aes(ymin = mean - 1*mcse,
                    ymax = mean + 1*mcse),
                width = .8,
                position = position_dodge(0.7),
                show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none",
        strip.text.x.top = ggplot2::element_blank())+
  labs(title = "",
       x = "",
       colour = "Method",
       y = "RMSE")


```


Create plot for .4
```{r viz-regression-power4}
plot4_rmsereg <- rmse_list[[3]] %>% 
  ggplot(aes(x = method, 
             y = mean, 
             colour = method,
             fill = method,
             group = method)) +
  geom_errorbar(aes(ymin = mean - 1*mcse,
                    ymax = mean + 1*mcse),
                width = .8,
                position = position_dodge(0.7),
                show.legend = FALSE)+
  geom_point(position = position_dodge(0.7), 
             size = 1.2) +
  ggh4x::facet_nested(dgp ~ heterogeneity + outcome,
                      axes = "all",
                      remove_labels = "y") +
  scale_x_discrete()+
  scale_y_continuous(expand = c(0, 0), limits = c(0,1)) +
  scale_color_manual(values = meth_colors) +
  theme_centrality() +
  theme(legend.position = "none",
        strip.text.x.top = ggplot2::element_blank())+
  labs(title = "",
       x = "Method",
       colour = "Method",
       y = "RMSE")

plot4_rmsereg
```

Combine Plots:

```{r plot-rmsereg-combined}
plot_rmse_combined <- cowplot::plot_grid(plot0_rmsereg, 
                                         plot2_rmsereg, 
                                         plot4_rmsereg, 
                                         ncol = 1,
                                        labels = c("True Effect: 0", 
                                                   "True Effect: 0.2",
                                                   "True Effect: 0.4"))
ggsave("plot_reg_rmse_combined_mock.svg", plot_rmse_combined, height = 12, width = 16,
       path = here::here("figures/"), device = "svg")

plot_rmse_combined

```




# Create Overview Table for Supplement
Create one long overview table over all performance measures for the supplement.
Probably will be long and unwieldy. 

```{r overview-table}

``` 



